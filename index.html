<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <style>
    body {
      margin: auto;
    }

    .my-canvas {
      position: absolute;
      border: 1px solid #d3d3d3;
      left: 50%;
      background: white;
      margin-left: -750px;
    }
  </style>
</head>
<body>
<canvas id="myCanvas" width="1600" height="1500" class="my-canvas"></canvas>
</body>
</html>
<script src="js/station.js"></script>
<script>
  /***
   *画布大小：1000*1000
   * 根据经纬度放大比例：1.5
   * 经度差（不包括16号线）：0.6230510000000038
   * 纬度差：0.5699329999999989
   * 保留位数：小数点后三位
   * 中心点：天安门西
   */
  var c = document.getElementById("myCanvas");
  var cxt = c.getContext("2d");
  //画一个实心圆

  var colorList = {
    1001: 'rgb(228,120,120)',
    1002: 'rgb(85,145,206)',
    1004: 'rgb(23,190,176)',
    1005: 'rgb(207, 112, 179)',
    1006: 'rgb(226, 161, 22)',
    1007: 'rgb(179, 143, 101)',
    1008: 'rgb(71, 184, 82)',
    1009: 'rgb(136, 173, 46)',
    1010: 'rgb(59, 174, 202)',
    1013: 'rgb(191, 126, 22)',
    1014: 'rgb(185, 128, 128)',
    1015: 'rgb(138, 112, 185)',
    1016: 'rgb(90, 142, 119)',
    1051: 'rgb(228, 120, 120)',
    1052: 'rgb(177, 134, 164)',
    1053: 'rgb(219, 130, 64)',
    1054: 'rgb(177, 153, 187)',
    1055: 'rgb(222, 89, 130)'
  };
  var colorIndex = 0;
  var currentLineIndex = '1001';
  var r = 3;
  var position = 700;
  var rate = 0.75;
  function drawMap(staPos) {
    for (var i = 0; i < staPos.length; i++) {
      //算当前点坐标
      var centerX = parseInt((parseFloat(staPos[i].cx) - parseFloat(centerPoint.cx)  ) * rate) + position;
      var centerY = parseInt((parseFloat(staPos[i].cy) - parseFloat(centerPoint.cy) ) * rate) + position;
      //获取id
      var id = parseInt(staPos[i].id);
      //获取所在线路
      var lineIndex = staPos[i].id.substr(0, 4);
      //如果不是最后一个点  画线
      if (i != staPos.length - 1) {
        //算先一个点的坐标
        var nextCenterX = parseInt((parseFloat(staPos[i + 1].cx) - parseFloat(centerPoint.cx)  ) * rate) + position;
        var nextCenterY = parseInt((parseFloat(staPos[i + 1].cy) - parseFloat(centerPoint.cy) ) * rate) + position;
        var nextId = parseInt(staPos[i + 1].id);
        //如果id相差1 说明是同线路相邻站点 画线
        if ((id + 1 == nextId) || (id - 1 == nextId)) {
          drawLine(cxt, centerX, centerY, nextCenterX, nextCenterY, 5, colorList[lineIndex], staPos[i].hasOwnProperty('bezier') ? staPos[i].bezier : undefined)
        }
        // 是否存在下一站 只有在环形中有此判断 用于闭合环形
        if (staPos[i].hasOwnProperty('nextStation')) {
          nextCenterX = parseInt((parseFloat(staPos[i]['nextStation'].cx) - parseFloat(centerPoint.cx)  ) * rate) + position;
          nextCenterY = parseInt((parseFloat(staPos[i]['nextStation'].cy) - parseFloat(centerPoint.cy) ) * rate) + position;
          drawLine(cxt, centerX, centerY, nextCenterX, nextCenterY, 5, colorList[lineIndex], staPos[i].hasOwnProperty('bezier') ? staPos[i].bezier : undefined);
          drawPoint(cxt, nextCenterX, nextCenterY, 3, 1, 'white', colorList[lineIndex])
        }
      }
      // 画点 换乘站
      if (staPos[i].transfer == 'true') {
        drawPoint(cxt, centerX, centerY, 5, 2, 'white', 'red')
      } else {//画点 非换乘站
        drawPoint(cxt, centerX, centerY, 3, 1, 'white', colorList[lineIndex])
      }
    }
  }
  function drawPoint(context, x, y, r, lineWidth, fillColor, strokeColor) {
    context.beginPath();
    context.lineWidth = lineWidth;//设置线宽
    context.arc(x, y, r, 0, 360, false);
    context.fillStyle = fillColor;//填充颜色
    context.strokeStyle = strokeColor; //线颜色
    context.fill(); //画实心圆
    context.stroke();//画空心圆
    context.closePath();
  }
  function drawLine(context, x, y, nx, ny, lineWidth, color, bezier) {
    if (!bezier) {
      context.strokeStyle = color;//线条颜色：绿色
      context.lineWidth = lineWidth;//设置线宽
      context.beginPath();
      context.moveTo(x, y);
      context.lineTo(nx, ny);
      context.stroke();//画线框
      context.fill();//填充颜色
      context.closePath();//可以把这句注释掉再运行比较下不同
    } else {
      context.strokeStyle = color;//线条颜色：绿色
      context.lineWidth = lineWidth;//设置线宽
      context.beginPath();
      context.moveTo(x, y);
      var bx = parseInt((parseFloat(bezier.x) - parseFloat(centerPoint.cx)  ) * rate) + position;
      var by = parseInt((parseFloat(bezier.y) - parseFloat(centerPoint.cy) ) * rate) + position;
      context.quadraticCurveTo(bx, by, nx, ny);
      context.stroke();//画线框
      context.closePath();//可以把这句注释掉再运行比较下不同
    }

  }
  drawMap(staPos);
</script>