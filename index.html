<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>subway</title>
    <style>
        body {
            margin: auto;
        }

        .my-canvas {
            position: absolute;
            border: 1px solid #d3d3d3;
            left: 50%;
            background: white;
            margin-left: -750px;
        }
    </style>
</head>
<body>
<canvas id="myCanvas" width="1600" height="1500" class="my-canvas"></canvas>
</body>
</html>
<script src="js/station.js"></script>
<script src="js/name.js"></script>
<script>

    window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;

    var colorList = {
        1001: 'rgb(228,120,120)',
        1002: 'rgb(85,145,206)',
        1004: 'rgb(23,190,176)',
        1005: 'rgb(207, 112, 179)',
        1006: 'rgb(226, 161, 22)',
        1007: 'rgb(179, 143, 101)',
        1008: 'rgb(71, 184, 82)',
        1009: 'rgb(136, 173, 46)',
        1010: 'rgb(59, 174, 202)',
        1013: 'rgb(191, 126, 22)',
        1014: 'rgb(185, 128, 128)',
        1015: 'rgb(138, 112, 185)',
        1016: 'rgb(90, 142, 119)',
        1051: 'rgb(228, 120, 120)',
        1052: 'rgb(177, 134, 164)',
        1053: 'rgb(219, 130, 64)',
        1054: 'rgb(177, 153, 187)',
        1055: 'rgb(222, 89, 130)'
    };
    var position = 700;
    var rate = 0.75;

    var fps = 30;
    var now;
    var then = Date.now();
    var interval = 1000 / fps;
    var delta;

    var RENDERER = {
        init: function () {
            this.setParameters();
            requestAnimationFrame(this.render);
        },
        setParameters: function () {
            this.cxt = document.getElementById("myCanvas").getContext("2d");
            this.cxt.imageSmoothingEnabled = true;
        },

        render: function () {
            requestAnimationFrame(RENDERER.render);
            now = Date.now();
            delta = now - then;
            if (delta > interval) {
                then = now - (delta % interval);
                RENDERER.cxt.clearRect(0, 0, 1600, 1500);
                RENDERER.drawMap();
            }
        },
        drawMap: function () {
            for (var i = 0; i < staPos.length; i++) {
                //算当前点坐标
                var centerX = parseInt((parseFloat(staPos[i].cx) - parseFloat(centerPoint.cx)  ) * rate) + position;
                var centerY = parseInt((parseFloat(staPos[i].cy) - parseFloat(centerPoint.cy) ) * rate) + position;
                //获取id
                var id = parseInt(staPos[i].id);
                //获取所在线路
                var lineIndex = staPos[i].id.substr(0, 4);
                //如果不是最后一个点  画线
                if (i != staPos.length - 1) {
                    //算先一个点的坐标
                    var nextCenterX = parseInt((parseFloat(staPos[i + 1].cx) - parseFloat(centerPoint.cx)  ) * rate) + position;
                    var nextCenterY = parseInt((parseFloat(staPos[i + 1].cy) - parseFloat(centerPoint.cy) ) * rate) + position;
                    var nextId = parseInt(staPos[i + 1].id);
                    //如果id相差1 说明是同线路相邻站点 画线
                    if ((id + 1 == nextId) || (id - 1 == nextId)) {
                        RENDERER.drawLine(RENDERER.cxt, centerX, centerY, nextCenterX, nextCenterY, 5, colorList[lineIndex], staPos[i].hasOwnProperty('bezier') ? staPos[i].bezier : undefined)
                    }
                    // 是否存在下一站 只有在环形中有此判断 用于闭合环形
                    if (staPos[i].hasOwnProperty('nextStation')) {
                        nextCenterX = parseInt((parseFloat(staPos[i]['nextStation'].cx) - parseFloat(centerPoint.cx)  ) * rate) + position;
                        nextCenterY = parseInt((parseFloat(staPos[i]['nextStation'].cy) - parseFloat(centerPoint.cy) ) * rate) + position;
                        RENDERER.drawLine(RENDERER.cxt, centerX, centerY, nextCenterX, nextCenterY, 5, colorList[lineIndex], staPos[i].hasOwnProperty('bezier') ? staPos[i].bezier : undefined);
                        RENDERER.drawPoint(RENDERER.cxt, nextCenterX, nextCenterY, 3, 1, 'white', colorList[lineIndex])
                    }
                }
                // 画点 换乘站
                if (staPos[i].transfer == 'true') {
                    RENDERER.drawPoint(RENDERER.cxt, centerX, centerY, 5, 2, 'white', 'red')
                } else {//画点 非换乘站
                    RENDERER.drawPoint(RENDERER.cxt, centerX, centerY, 3, 1, 'white', colorList[lineIndex])
                }
                var nameX = parseInt((parseFloat(staPos[i].namePoint.x) - parseFloat(centerPoint.cx)-10) * rate) + position;
                var nameY = parseInt((parseFloat(staPos[i].namePoint.y) - parseFloat(centerPoint.cy)) * rate) + position;
                RENDERER.drawText(RENDERER.cxt, nameX, nameY, staPos[i].name, 'black');
            }
        },
        drawPoint: function (context, x, y, r, lineWidth, fillColor, strokeColor) {
            context.beginPath();
            context.lineWidth = lineWidth;//设置线宽
            context.arc(x, y, r, 0, 360, false);
            context.fillStyle = fillColor;//填充颜色
            context.strokeStyle = strokeColor; //线颜色
            context.fill(); //画实心圆
            context.stroke();//画空心圆
            context.closePath();
        },
        drawLine: function (context, x, y, nx, ny, lineWidth, color, bezier) {
            if (bezier) {
                context.strokeStyle = color;//线条颜色：绿色
                context.lineWidth = lineWidth;//设置线宽
                context.beginPath();
                context.moveTo(x, y);
                var bx = parseInt((parseFloat(bezier.x) - parseFloat(centerPoint.cx)  ) * rate) + position;
                var by = parseInt((parseFloat(bezier.y) - parseFloat(centerPoint.cy) ) * rate) + position;
                if (bezier.hasOwnProperty('x2')) {
                    var bx2 = parseInt((parseFloat(bezier.x2) - parseFloat(centerPoint.cx)  ) * rate) + position;
                    var by2 = parseInt((parseFloat(bezier.y2) - parseFloat(centerPoint.cy) ) * rate) + position;
                    context.bezierCurveTo(bx, by, bx2, by2, nx, ny);
                } else {
                    context.quadraticCurveTo(bx, by, nx, ny);
                }
                context.stroke();//画线框
                context.closePath();//可以把这句注释掉再运行比较下不同
            } else {
                context.strokeStyle = color;//线条颜色：绿色
                context.lineWidth = lineWidth;//设置线宽
                context.beginPath();
                context.moveTo(x, y);
                context.lineTo(nx, ny);
                context.stroke();//画线框
                context.fill();//填充颜色
                context.closePath();//可以把这句注释掉再运行比较下不同
            }

        },
        drawText: function (context, x, y, text, color) {
            context.fillStyle = color;//线条颜色：绿色
            context.font = "6px Microsoft YaHei";
            context.fillText(text, x, y);
        }
    };
    RENDERER.init();
    console.log(JSON.stringify(staPos));

</script>